# CI/CD pipeline for the Task Manager CLI Java project.
# Stages: build -> verify -> test -> package -> release -> docs.

image: maven:3.9.6-eclipse-temurin-17

stages:
  - build
  - verify
  - test
  - package
  - release
  - docs

variables:
  # Use a local Maven repository inside the job workspace
  # to avoid downloading dependencies from scratch on each job.
  MAVEN_OPTS: "-Dmaven.repo.local=.m2/repository"
  # Name of the Docker image built in the release stage.
  CONTAINER_IMAGE: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"

# Default step executed before each job that does not override before_script.
before_script:
  - echo "Using Maven with Temurin JDK 17"

# -----------------------------------------------------------------------------
# BUILD STAGE
# -----------------------------------------------------------------------------

# Compile the project and resolve all Maven dependencies.
build:
  stage: build
  cache:
    key:
      files:
        - pom.xml
    paths:
      - .m2/repository/
    policy: pull-push
  script:
    - mvn clean compile
  artifacts:
    # Compiled classes and other build outputs.
    paths:
      - target/
    expire_in: 1 day

# -----------------------------------------------------------------------------
# VERIFY STAGE
# Static and dynamic analysis jobs run in parallel.
# -----------------------------------------------------------------------------

# Static analysis - code style and formatting (Checkstyle).
checkstyle:
  stage: verify
  cache:
    key:
      files:
        - pom.xml
    paths:
      - .m2/repository/
    policy: pull
  script:
    - mvn checkstyle:check
  # Do not block the pipeline because of style violations,
  # but keep the report available for inspection.
  allow_failure: true
  artifacts:
    paths:
      - target/checkstyle-result.xml
    expire_in: 7 days

# Static analysis - potential bugs and bad patterns (SpotBugs).
spotbugs:
  stage: verify
  cache:
    key:
      files:
        - pom.xml
    paths:
      - .m2/repository/
    policy: pull
  script:
    - mvn spotbugs:check
  # Treat findings as quality feedback, not as hard blockers.
  allow_failure: true
  artifacts:
    paths:
      - target/spotbugsXml.xml
    expire_in: 7 days

# Dynamic analysis - run the unit test suite as part of the verify stage.
# This job provides a first dynamic execution of the code in parallel
# with the static analysis jobs.
dynamic-analysis:
  stage: verify
  cache:
    key:
      files:
        - pom.xml
    paths:
      - .m2/repository/
    policy: pull
  dependencies:
    - build
  script:
    # Executes test to record the test coverage
    - mvn test jacoco:report
    # Prints the results of the coverage
    - cat target/site/jacoco/index.html | grep -o 'Total[^%]*%' || echo "Coverage info not found"
  artifacts:
    paths:
      - target/site/jacoco/
    expire_in: 30 days

# -----------------------------------------------------------------------------
# TEST STAGE
# Unit tests run first, then integration tests if unit tests pass (fail-fast).
# -----------------------------------------------------------------------------

# Unit tests - test individual components in isolation.
# Excludes integration tests (classes ending with IntegrationTest).
unit-tests:
  stage: test
  cache:
    key:
      files:
        - pom.xml
    paths:
      - .m2/repository/
    policy: pull
  script:
    - mvn test -Dtest='!*IntegrationTest'
  artifacts:
    reports:
      junit: target/surefire-reports/TEST-*.xml
    paths:
      - target/surefire-reports/
    expire_in: 30 days

# Integration tests - test the interaction between components.
# Runs only classes ending with IntegrationTest.
# Executes only if unit tests pass (fail-fast approach).
integration-tests:
  stage: test
  cache:
    key:
      files:
        - pom.xml
    paths:
      - .m2/repository/
    policy: pull
  needs:
    - unit-tests
  script:
    - mvn test -Dtest='*IntegrationTest'
  artifacts:
    reports:
      junit: target/surefire-reports/TEST-*.xml
    paths:
      - target/surefire-reports/
    expire_in: 30 days

# -----------------------------------------------------------------------------
# PACKAGE STAGE
# -----------------------------------------------------------------------------

# Build the executable JAR that can be distributed or used by the release stage.
package:
  stage: package
  cache:
    key:
      files:
        - pom.xml
    paths:
      - .m2/repository/
    policy: pull
  script:
    # Tests already run in verify and test stages, so we can skip them here.
    - mvn package -DskipTests
  artifacts:
    # Final JAR artifact produced by Maven.
    paths:
      - target/task-manager-cli-*.jar
    expire_in: 90 days
    # Include the short commit SHA in the artifact name for traceability.
    name: "task-manager-cli-$CI_COMMIT_SHORT_SHA"
  # Only package artifacts from the main branch.
  only:
    - main

# -----------------------------------------------------------------------------
# RELEASE STAGE
# -----------------------------------------------------------------------------

# Build a Docker image with the packaged application and push it
# to the GitLab Container Registry.

release:
  stage: release
  image: docker:27.3.1
  cache: {}
  services:
    - docker:27.3.1-dind
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  script:
    - echo "Using Docker client:"
    - docker version
    # Authenticate to the GitLab Container Registry.
    - echo "$CI_JOB_TOKEN" | docker login -u gitlab-ci-token --password-stdin "$CI_REGISTRY"
    # Build the Docker image using the Dockerfile in the repository root.
    - docker build -t "$CONTAINER_IMAGE" .
    # Push the image so that it can be used by the deploy stage or other environments.
    - docker push "$CONTAINER_IMAGE"
  # Download the JAR produced in the package stage.
  dependencies:
    - package
  only:
    - main

# -----------------------------------------------------------------------------
# DOCS STAGE
# -----------------------------------------------------------------------------

# Generate Javadoc and prepare it for publishing with GitLab Pages.

pages:
  stage: docs
  cache:
    key:
      files:
        - pom.xml
    paths:
      - .m2/repository/
    policy: pull
  script:
    # Generate API documentation under 'target/site/apidocs'.
    - mvn javadoc:javadoc
    # GitLab Pages expects a 'public' directory as the site root.
    - mv target/site/apidocs public
  artifacts:
    # Everything under 'public' will be served as a static site
    # when GitLab Pages is enabled for the project.
    paths:
      - public
    expire_in: 30 days
  # Only publish documentation for the main branch.
  only:
    - main
